# useState

## 从问题开始分析

下面针对一些刚接触 react-hook 时写出的问题代码进行分析

1. 顺序执行

   ```ts
   const [a, useA] = useState(1);
   if ("yes") {
     const [b, useB] = useState(2);
   }
   ```

   开发环境立刻报了 error  
   ESlint 的提示是  
   `React Hook "useState" is called conditionally. React Hooks must be called in the exact same order in every component render.`  
   简单来说 useState 不允许有条件的调用,必须按顺序执行.

2. n 到底是哪个 n?

   - 连续调用 setN  
     预期结果时 得到  10,但是最终结果时4,说明四个setN 只执行了了最后一个,执行时拿到的n 时初始的n
   ```jsx
   function App() {
     const [n, setN] = useState(0);
     const onClick = () => {
        setN(n + 1);
        setN(n + 2);
        setN(n + 3);
        setN(n + 4);
     };
     return (
       <div className="App">
         <div>n: {n}</div>
         <button onClick={onClick}>+10</button>
       </div>
     );
   }
   ```

   - 定时器里的 n
     - 先点 +1 再点 wait console 显示 1
     - 先点 wait 再点 +1 console 显示 0
     - 简单来说 setTimeout 里拿到的 n 是注册定时器时拿到 n 而不是定时器 里
     ```jsx
     function App() {
       const [n, setN] = React.useState(0);
       const wait = () => setTimeout(() => console.log(`n: ${n}`), 1000);
       return (
         <div className="App">
           <p>n:{n}</p>
           <p>
             <button onClick={() => setN(n + 1)}>+1</button>
             <button onClick={wait}>wait</button>
           </p>
         </div>
       );
     }
     ```

   ```

   ```

下面由这两个问题入手分析(瞎猜)hook 的原理

## 分析

### App 的渲染过程

通过打 log 观察到如下规律

- 初次渲染:
  1. React.render(App)
  2. 调用函数 App
  3. 函数 App 返回了虚拟 div(是个对象)
  4. 渲染成真实的 div
- 状态修改:
  1. 点击 button 调用 setN 修改了 n
  2. 再次 React.render(App)
  3. 再次调用函数 App
  4. 函数 App 返回了新的虚拟 div(是个对象)
  5. 渲染成的新的真实的 div(有个 dom diff 的过程)

由此可见

1. 每次渲染 都会运行一次 React.render, App, React.useState,
2. App 每次运行都会返回一个新的虚拟 div(是个对象,这点很重要)
3. 每次触发 setN 把新的 n 存到 虚拟 div 里(是个对象),从而触发 React.render
4. 每个虚拟 div 对象 都有自己的数据 state 来存放 n 这样的数据

### 由以上现象实现一个简易版的 useState

#### 第一版

```jsx
let _fakeState;

const fakeUseState = initialValue => {
  _fakeState = _fakeState === undefined ? initialValue : _fakeState;
  const setState = newValue => {
    _fakeState = newValue;
    fakeRender();
  };
  return [_fakeState, setState];
};

const fakeRender = component => {
  React.render(component, rootElement);
};
```

[在线 demo](https://codesandbox.io/s/broken-wave-bl09k)

#### 第二版

第一版虽然跑通了  
但是 \_fakeState 只能存一个值,这导致 fakeUseState 只能处理一组数据,  
考虑 \_fakeState 能否改成对象?  
结论是不可行, 因为没法把每个 fake UseState 的数据 和 对象里的 key 对应起来

#### 第三版

第二版里 \_fakeState 改成对象的模式不可行,
方案改为 \_fakeState 设置为数组 ,根据 每个 fakeUseState 的使用顺序来计算 在 \_fakeState 中的索引
代码如下

```jsx
// _fakeState 改为数组 ,这样就能多次使用 fakeUseState 了
let _fakeState = [];
let _index = 0;
const fakeUseState = initialValue => {
  let cuttentIndex = _index;
  // 这行就是为什么 state hook 必须按顺序执行的关键
  _index += 1;
  _fakeState[cuttentIndex] = _fakeState[cuttentIndex] || initialValue;
  const setState = newValue => {
    console.log(newValue);
    _fakeState[cuttentIndex] = newValue;
    fakeRender();
  };
  return [_fakeState[cuttentIndex], setState];
};

const fakeRender = () => {
  // 执行重新渲染 重置 _index
  _index = 0;
  ReactDOM.render(<App />, rootElement);
};
```

这次升级之后 fakeUseState 基本实现了 useState 的功能,  
它存储数据的模式解释了为什么 state hook 必须要按顺序执行.

[在线 demo](https://codesandbox.io/s/broken-wave-bl09k)

#### 问题 1 的解释

\_fakeState 和 \_index 存放在哪?  
如何防止多个组件都有 fakeUseState 的时候出现命名冲突?
刚才反复强调,每个函数组件都会返回一个对象,  
 每个组件的 \_fakeState 和 \_index 就放在这个返回出来 的对象里




## 总结
1. 每次渲染,函数组件都会重新执行一次
2. setN 不会改变当前的 n


## 参考

1. [react-hook 的实现](https://juejin.im/post/5bdfc1c4e51d4539f4178e1f)
